import {App} from '@slack/bolt';
import {config} from '../config';
import {GoogleGenerativeAI, HarmBlockThreshold, HarmCategory} from '@google/generative-ai';
import {GoogleAuth} from 'google-auth-library';
import fetch from 'node-fetch';
import {ChartJSNodeCanvas} from 'chartjs-node-canvas';
import {ChartConfiguration} from 'chart.js';
import {addToWatchlist, getWatchlist, removeFromWatchlist} from './watchlist-db';

export interface AIResponse {
    text: string;
    confidence: number;
}

// Example AI handler - you can replace this with actual AI integration
export class AIHandler {
    private app: App;
    private gemini: GoogleGenerativeAI;
    private auth: GoogleAuth;

    constructor(app: App) {
        this.app = app;
        this.gemini = new GoogleGenerativeAI(config.gemini.apiKey);

        // Initialize Google Auth for direct API calls
        this.auth = new GoogleAuth({
            scopes: 'https://www.googleapis.com/auth/cloud-platform',
        });

        this.setupAIHandlers();
    }

    private setupAIHandlers(): void {
        // New command handler for !watchlist
        this.app.message(/^!watchlist/i, async ({message, say}) => {
            if (!('user' in message) || !message.user) return;

            const userWatchlist = await getWatchlist(message.user);
            if (userWatchlist.length === 0) {
                await say({
                    text: "Your watchlist is empty. Add stocks with `!watch <TICKER>`.",
                });
                return;
            }

            let totalPortfolioValue = 0;
            let totalCostBasis = 0;

            const report = await Promise.all(
                userWatchlist.map(async (item) => {
                    const quote = await this.fetchQuoteData(item.ticker);
                    if (!quote) {
                        return `*${item.ticker}*: Could not retrieve current price.`;
                    }
                    const currentPrice = quote.price;
                    const gainLoss = (currentPrice - item.purchasePrice) * item.shares;
                    const gainLossPercent = (gainLoss / (item.purchasePrice * item.shares)) * 100;
                    const emoji = gainLoss >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';
                    const sign = gainLoss >= 0 ? '+' : '';

                    const costBasis = item.purchasePrice * item.shares;
                    totalCostBasis += costBasis;
                    totalPortfolioValue += currentPrice * item.shares;

                    return `*${item.ticker}* (${item.shares} @ $${item.purchasePrice.toFixed(2)}): $${(currentPrice * item.shares).toFixed(2)} | P/L: ${sign}$${gainLoss.toFixed(2)} (${sign}${gainLossPercent.toFixed(2)}%) ${emoji}`;
                })
            );

            const overallGainLoss = totalPortfolioValue - totalCostBasis;
            const overallGainLossPercent = (overallGainLoss / totalCostBasis) * 100;
            const overallSign = overallGainLoss >= 0 ? '+' : '';
            const overallEmoji = overallGainLoss >= 0 ? 'ðŸ”¼' : 'ðŸ”½';

            const summary = `*Your Watchlist Summary* ${overallEmoji}\nOverall P/L: ${overallSign}$${overallGainLoss.toFixed(2)} (${overallSign}${overallGainLossPercent.toFixed(2)}%)\n------------------------------------`;

            await say({
                text: `${summary}\n${report.join('\n')}`,
            });
        });

        // New command handler for !watch (help)
        this.app.message(/^!watch$/i, async ({say}) => {
            await say({
                text: 'Usage: `!watch <TICKER> [purchase_date] [purchase_price] [shares]`\n' +
                    'â€¢ `<TICKER>`: The stock symbol (e.g., AAPL).\n' +
                    'â€¢ `[purchase_date]`: Optional. Date of purchase (e.g., 2023-01-15). Defaults to today.\n' +
                    'â€¢ `[purchase_price]`: Optional. Price per share. Defaults to current market price.\n' +
                    'â€¢ `[shares]`: Optional. Number of shares. Defaults to 1.',
            });
        });

        // New command handler for !watch (add)
        this.app.message(/^!watch\s+([A-Z]+)(?:\s+([\d.-]+))?(?:\s+([\d.]+))?(?:\s+(\d+))?/i, async ({message, context, say}) => {
            if (!('user' in message) || !message.user || !context.matches?.[1]) return;

            const ticker = context.matches[1].toUpperCase();
            const purchaseDateInput = context.matches[2];
            const purchasePriceInput = context.matches[3];
            const sharesInput = context.matches[4];

            let purchasePrice = purchasePriceInput ? parseFloat(purchasePriceInput) : undefined;
            const purchaseDate = purchaseDateInput ? new Date(purchaseDateInput).toLocaleDateString() : new Date().toLocaleDateString();
            const shares = sharesInput ? parseInt(sharesInput, 10) : 1;

            if (purchasePrice === undefined) {
                const quote = await this.fetchQuoteData(ticker);
                if (!quote) {
                    await say({text: `Could not fetch the current price for *${ticker}*. Please provide a purchase price or try again later.`});
                    return;
                }
                purchasePrice = quote.price;
            }

            await addToWatchlist({
                userId: message.user,
                ticker,
                shares,
                purchaseDate,
                purchasePrice,
            });

            await say({text: `*${ticker}* (${shares} shares) has been added to your watchlist at $${purchasePrice.toFixed(2)}/share.`});
        });

        // New command handler for !unwatch
        this.app.message(/^!unwatch\s+([A-Z]+)/i, async ({message, context, say}) => {
            if (!('user' in message) || !message.user || !context.matches?.[1]) return;
            const ticker = context.matches[1].toUpperCase();

            const success = await removeFromWatchlist(message.user, ticker);

            if (success) {
                await say({text: `*${ticker}* has been removed from your watchlist.`});
            } else {
                await say({text: `*${ticker}* was not found in your watchlist.`});
            }
        });

        // New command handler for !chart
        this.app.message(/^!chart ([A-Z]+)(?:\s+(1m|3m|6m|1y|5y))?/i, async ({message, context, say, client}) => {
            if (!('user' in message) || !context.matches?.[1]) return;

            if (!config.alphaVantageApiKey) {
                await say({
                    text: 'The charting feature is not configured. An API key for Alpha Vantage is required.',
                });
                return;
            }

            const ticker = context.matches[1].toUpperCase();
            const range = context.matches[2] || '1y'; // Default to 1 year

            try {
                const workingMessage = await say({text: `ðŸ“ˆ Generating chart for *${ticker}* over the last *${range}*...`});

                const now = Math.floor(Date.now() / 1000);
                const from = this.calculateFromTimestamp(now, range);

                const candles = await this.getStockCandles(ticker);
                if (candles.length === 0) {
                    await say({text: `No data found for *${ticker}* in the selected range.`});
                    if (workingMessage.ts) await client.chat.delete({channel: message.channel, ts: workingMessage.ts});
                    return;
                }

                const chartImage = await this.generateChart(ticker, candles);

                await client.files.uploadV2({
                    channel_id: message.channel,
                    initial_comment: `Here's the chart for <@${message.user}> for *${ticker}* (${range}):`,
                    file: chartImage,
                    filename: `${ticker}_chart.png`,
                    title: `${ticker} Chart (${range})`,
                });

                if (workingMessage.ts) {
                    await client.chat.delete({channel: message.channel, ts: workingMessage.ts});
                }

            } catch (error) {
                console.error(`Chart generation error for ${ticker}:`, error);
                await say({text: `Sorry, I couldn't generate the chart. Error: ${(error as Error).message}`});
            }
        });

        // New command handler for !cq
        this.app.message(/^!cq (.+)/i, async ({message, context, say}) => {
            if (!('user' in message) || !context.matches?.[1]) {
                return;
            }

            if (!config.finnhubApiKey) {
                await say({
                    text: 'The crypto quote feature is not configured. An API key for Finnhub is required.',
                });
                return;
            }

            const tickers = context.matches[1].trim().toUpperCase().split(/\s+/);
            if (tickers.length === 0) {
                await say({
                    text: 'Please provide at least one crypto ticker. Example: `!cq BTC ETH`',
                });
                return;
            }

            try {
                const results = await Promise.all(
                    tickers.map((ticker: string) => {
                        const cryptoTicker = `BINANCE:${ticker}USDT`;
                        return this.formatQuote(cryptoTicker, ticker);
                    })
                );
                const reply = results.join('\n');
                await say({text: reply});
            } catch (error) {
                console.error('Finnhub API error:', error);
                await say({
                    text: `Sorry, I couldn't fetch the crypto prices. Error: ${(error as Error).message}`,
                });
            }
        });

        // New command handler for !q
        this.app.message(/^!q (.+)/i, async ({message, context, say}) => {
            if (!('user' in message) || !context.matches?.[1]) {
                return;
            }

            if (!config.finnhubApiKey) {
                await say({
                    text: 'The stock quote feature is not configured. An API key for Finnhub is required.',
                });
                return;
            }

            const tickers = context.matches[1].trim().toUpperCase().split(/\s+/);
            if (tickers.length === 0) {
                await say({
                    text: 'Please provide at least one stock ticker. Example: `!q AAPL TSLA`',
                });
                return;
            }

            try {
                const results = await Promise.all(
                    tickers.map((ticker: string) => this.formatQuote(ticker))
                );
                const reply = results.join('\n');
                await say({text: reply});
            } catch (error) {
                console.error('Finnhub API error:', error);
                await say({
                    text: `Sorry, I couldn't fetch the stock prices. Error: ${(error as Error).message}`,
                });
            }
        });

        // Respond to public messages that start with !gem
        this.app.message(/^!gem (.+)/i, async ({message, context, say}) => {
            if ('user' in message && say) {
                const question = context.matches[1].trim();
                if (!question) {
                    await say({text: 'Please provide a question after !gem.', thread_ts: message.ts});
                    return;
                }
                try {
                    const response = await this.processAIQuestion(question);
                    await say({
                        text: `ðŸ¤– <@${message.user}> asked: "${question}"
${response.text}`,
                        thread_ts: message.ts,
                    });
                } catch (error) {
                    console.error('Gemini API error (!gem message):', error);
                    await say({text: `Sorry <@${message.user}>, I couldn't process that request.`, thread_ts: message.ts});
                }
            }
        });

        // Add new !image handler for Imagen 4
        this.app.message(/^!image (.+)/i, async ({message, context, client, say}) => {
            if (!('user' in message)) {
                return;
            }

            const prompt = context.matches[1].trim();

            if (!prompt) {
                await say({text: 'Please provide a prompt for the image after `!image`.'});
                return;
            }

            try {
                // Let the user know we're working on it
                const workingMessage = await say({
                    text: `ðŸŽ¨ Generating an image with a direct API call for prompt: "_${prompt}_"... this can take a moment.`
                });

                // Generate the image
                const result = await this.generateImage(prompt);

                if (result.filteredReason) {
                    await say({
                        text: `Sorry, I can't generate that image. It was blocked for the following reason: *${result.filteredReason}*`,
                    });
                    if (workingMessage.ts) {
                        await client.chat.delete({channel: message.channel, ts: workingMessage.ts});
                    }
                    return;
                }

                if (result.imageBase64) {
                    // Upload the image to Slack
                    await client.files.uploadV2({
                        channel_id: message.channel,
                        initial_comment: `Here's the image for <@${message.user}>, prompted by: "_${prompt}_"`,
                        file: Buffer.from(result.imageBase64, 'base64'),
                        filename: 'imagen4-image.png',
                        title: prompt,
                    });
                }

                // Delete the "working on it" message if we can
                if (workingMessage.ts) {
                    await client.chat.delete({
                        channel: message.channel,
                        ts: workingMessage.ts
                    });
                }

            } catch (error) {
                console.error('Imagen API error:', error);
                await say({text: `Sorry, I couldn't generate an image. Error: ${(error as Error).message}`});
            }
        });

        // New command for !stocknews
        this.app.message(/^!stocknews/i, async ({message, say}) => {
            if (!('user' in message)) {
                return;
            }

            if (!config.finnhubApiKey) {
                await say({text: 'The stock news feature is not configured. An API key for Finnhub is required.'});
                return;
            }

            try {
                const articles = await this.fetchStockNews();

                if (!articles || articles.length === 0) {
                    await say({
                        text: 'I couldn't find any recent stock market news.', thread_ts: message.ts});
                    return;
                    }

                // Format the top 5 articles
                const formattedArticles = articles
                        .slice(0, 5)
                        .map(
                            (article) => `â€¢ *${article.headline}* - _${article.source}_\n   <${article.url}|Read More>`
                        )
                        .join('\n\n');

                    await say({
                        text: `Here are the latest headlines:\n\n${formattedArticles}`,
                        thread_ts: message.ts,
                    });
                } catch (error) {
                    console.error('Stock news error:', error);
                    await say({
                        text: `Sorry, I couldn't fetch the stock news. Error: ${(error as Error).message}`,
                        thread_ts: message.ts,
                    });
                }
            });

        // Optionally, you can keep the AI mention handler or remove it if you want only !gem
        // this.app.message(/ai|AI/, async ({ message, say }) => { ... });
    }

    private calculateFromTimestamp(now: number, range: string): number {
        const day = 60 * 60 * 24;
        switch (range) {
            case '1m': return now - 30 * day;
            case '3m': return now - 90 * day;
            case '6m': return now - 180 * day;
            case '5y': return now - 5 * 365 * day;
            case '1y':
            default:
                return now - 365 * day;
        }
    }

    private async getStockCandles(ticker: string): Promise<{t: number; c: number}[]> {
        const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${ticker}&apikey=${config.alphaVantageApiKey}&outputsize=full`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Alpha Vantage API request failed: ${response.statusText}`);
        }
        const data = (await response.json()) as {"Time Series (Daily)"?: {[key: string]: {"4. close": string}}};
        const timeSeries = data["Time Series (Daily)"];

        if (!timeSeries) {
            return [];
        }

        return Object.entries(timeSeries)
            .map(([date, values]) => ({
                t: new Date(date).getTime(),
                c: parseFloat(values["4. close"]),
            }))
            .reverse(); // Data comes in reverse chronological order
    }

    private async generateChart(ticker: string, data: {t: number; c: number}[]): Promise<Buffer> {
        const width = 800;
        const height = 400;
        const chartJSNodeCanvas = new ChartJSNodeCanvas({width, height, backgroundColour: '#ffffff'});

        const lastPrice = data[data.length - 1].c;
        const firstPrice = data[0].c;
        const isUp = lastPrice >= firstPrice;
        const color = isUp ? 'rgb(75, 192, 192)' : 'rgb(255, 99, 132)';

        const configuration: ChartConfiguration = {
            type: 'line',
            data: {
                labels: data.map(d => new Date(d.t).toLocaleDateString()),
                datasets: [
                    {
                        label: `${ticker} Closing Price`,
                        data: data.map(d => d.c),
                        borderColor: color,
                        backgroundColor: color + '33', // Add some transparency
                        fill: true,
                        pointRadius: 0,
                        tension: 0.4,
                    },
                ],
            },
            options: {
                scales: {
                    x: {
                        ticks: {
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 10,
                        },
                    },
                    y: {
                        ticks: {
                            callback: value => '$' + value,
                        },
                    },
                },
                plugins: {
                    legend: {
                        display: false,
                    },
                },
            },
        };

        return await chartJSNodeCanvas.renderToBuffer(configuration);
    }

    private async fetchQuoteData(ticker: string): Promise<{price: number; change: number; percentChange: number} | null> {
        if (!config.finnhubApiKey) {
            console.error('Finnhub API key is not configured.');
            return null;
        }
        const url = `https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${config.finnhubApiKey}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                console.error(`Finnhub API bad response for ${ticker}: ${response.statusText}`);
                return null;
            }
            const data = (await response.json()) as {c: number; d: number; dp: number};

            if (!data || typeof data.c === 'undefined') {
                return null;
            }

            return {
                price: data.c, // current price
                change: data.d, // change
                percentChange: data.dp, // percent change
            };
        } catch (error) {
            console.error(`Error fetching quote for ${ticker}:`, error);
            return null;
        }
    }

    private async formatQuote(ticker: string, displayName?: string): Promise<string> {
        const displayTicker = displayName || ticker;
        const quote = await this.fetchQuoteData(ticker);

        if (!quote) {
            return `*${displayTicker}*: No data found (is this a valid ticker?)`;
        }

        const {price, change, percentChange} = quote;
        const sign = change >= 0 ? '+' : '';
        const emoji = change >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';

        return `*${displayTicker}*: $${price.toFixed(2)} (${sign}${change.toFixed(2)}, ${sign}${percentChange.toFixed(2)}%) ${emoji}`;
    }

    private async processAIQuestion(question: string): Promise<AIResponse> {
        // Use Gemini API to generate a response
        const model = this.gemini.getGenerativeModel({
            model: 'gemini-2.5-flash',
            safetySettings: [
                {category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE},
                {category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE},
                {category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE},
                {category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE},
            ],
        });
        const result = await model.generateContent(question);
        const text = result.response.text();
        return {
            text,
            confidence: 100, // Gemini does not provide a confidence score
        };
    }

    private async generateImage(prompt: string): Promise<{imageBase64?: string; filteredReason?: string}> {
        const token = await this.auth.getAccessToken();

        const projectId = config.vertex.projectId;
        const location = config.vertex.location;
        const modelId = 'imagen-4.0-generate-preview-06-06';

        const apiEndpoint = `${location}-aiplatform.googleapis.com`;
        const url = `https://${apiEndpoint}/v1/projects/${projectId}/locations/${location}/publishers/google/models/${modelId}:predict`;

        const requestBody = {
            instances: [
                {
                    prompt: prompt,
                },
            ],
            parameters: {
                sampleCount: 1, // We only need one image for the bot
                // Ask the API to include the reason if an image is filtered.
                includeRaiReason: true,
            },
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${token}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
            const errorBody = await response.text();
            console.error('Imagen API response error:', response.status, errorBody);
            throw new Error(`Imagen API request failed with status ${response.status}: ${errorBody}`);
        }

        const data = (await response.json()) as {
            predictions: [
                {
                    bytesBase64Encoded?: string;
                    raiFilteredReason?: string;
                },
            ];
        };

        if (data.predictions?.[0]?.raiFilteredReason) {
            return {filteredReason: data.predictions[0].raiFilteredReason};
        }

        if (data.predictions?.[0]?.bytesBase64Encoded) {
            return {imageBase64: data.predictions[0].bytesBase64Encoded};
        }

        throw new Error('Invalid response structure from Imagen API.');
    }
} 